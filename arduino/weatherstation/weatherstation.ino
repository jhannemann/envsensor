#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
#include <WiFi101.h>
#include <WiFiMDNSResponder.h>

// #define NDEBUG

#define BUTTON_1_PIN 2
#define BUTTON_2_PIN 3
#define OLED_RESET_PIN 4

#define SENSOR_PERIOD 1000 // ms
#define DEBOUNCE_DELAY 50 // ms

const char ssid[] = "mynetwork";
const char pass[] = "mypassword";
char mdnsName[] = "weather00";

enum State {
  IDLE_STATE,
  DISPLAY_LAST,
  DISPLAY_MAX,
  DISPLAY_MIN,
  DISPLAY_UNIT,
  RESET_HIST
};

enum Event {
  BUTTON_1_PRESS,
  BUTTON_2_PRESS,
  SENSOR_TIMEOUT,
  NUM_EVENTS
};

State state;
bool eventFlags[NUM_EVENTS] = {false,
                               false,
                               false};

unsigned long timerStart;
unsigned long now;

float temperature;
float humidity;
float pressure;
bool metric = true;

// This is the driver for the accelerometer.
// This will eventually be removed.
#include <Adafruit_LSM303_U.h>
Adafruit_LSM303_Accel_Unified accel(42);

Adafruit_BME280 sensor;
Adafruit_SSD1306 display(OLED_RESET_PIN);

WiFiMDNSResponder mdnsResponder;
WiFiServer server(80);

#define ksu_logo_width 99
#define ksu_logo_height 55
static const unsigned char PROGMEM ksu_logo_bits[] = {
 0x00,0x00,0x00,0x00,0x01,0xb6,0xed,0xb0,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x01,0xb6,0xed,0xb0,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x7f,0xff,0xc0,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x7f,0xff,0xc0,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00
,0x00,0x00,0x00,0x00,0x00,0x3f,0xff,0x80,0x00,0x00,0x00,0x00,0x00
,0xd6,0x00,0x00,0x00,0x00,0x3c,0x07,0x80,0x00,0x00,0x00,0x0d,0x60
,0x54,0x00,0x00,0x00,0x00,0x3c,0x07,0x80,0x00,0x00,0x00,0x05,0x40
,0x00,0x00,0x00,0x00,0x00,0x3c,0x07,0x80,0x00,0x00,0x00,0x00,0x00
,0x7c,0x00,0x00,0x00,0x00,0x3c,0x07,0x80,0x00,0x00,0x00,0x07,0xc0
,0x7c,0x00,0x00,0x00,0x00,0x3c,0x07,0x80,0x00,0x00,0x00,0x07,0xc0
,0x7d,0xdb,0x6d,0xb6,0xdb,0xbc,0x07,0xbb,0x6d,0xb6,0xdb,0x77,0xc0
,0x7d,0xdb,0x6d,0xb6,0xdb,0xbc,0x07,0xbb,0x6d,0xb6,0xdb,0x77,0xc0
,0x7d,0xdb,0x6d,0xb6,0xdb,0xbc,0x07,0xbb,0x6d,0xb6,0xdb,0x77,0xc0
,0x7c,0x00,0x00,0x00,0x00,0x3c,0x07,0x80,0x00,0x00,0x00,0x07,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xfc,0x07,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xff,0xff,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0x81,0xf8,0x1f,0x81,0xfc,0x07,0xf0,0x3f,0x03,0xf0,0x37,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xfc,0x07,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xfc,0x07,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xfc,0x07,0xff,0xff,0xff,0xff,0xf7,0xc0
,0x7d,0xff,0xff,0xff,0xff,0xfc,0x07,0xff,0xff,0xff,0xff,0xf7,0xc0 };

#define verizon_logo_width 128
#define verizon_logo_height 35
static const unsigned char PROGMEM verizon_logo_bits[] = {
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e
,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0c
,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c
,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c
,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38
,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38
,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70
,0x00,0x00,0x00,0xfc,0x00,0x00,0x80,0x00,0x00,0x00,0x7e,0x00,0x00,0xf8,0x00,0x70
,0xfc,0x07,0xe3,0xff,0x03,0xe3,0xdf,0xbf,0xff,0xc1,0xff,0x81,0xfb,0xfc,0x70,0x60
,0x7c,0x07,0xc7,0xff,0x83,0xe7,0xdf,0xbf,0xff,0xc3,0xff,0xc1,0xfb,0xfe,0x70,0xe0
,0x7e,0x0f,0xcf,0xff,0xc3,0xff,0xdf,0xbf,0xff,0xc7,0xff,0xe1,0xff,0xff,0x38,0xc0
,0x7e,0x0f,0xcf,0xff,0xe3,0xff,0xdf,0xbf,0xff,0xcf,0xff,0xf1,0xff,0xff,0x39,0xc0
,0x3e,0x0f,0x9f,0x87,0xe3,0xff,0xdf,0xbf,0xff,0xcf,0xe3,0xf9,0xff,0xff,0x19,0xc0
,0x3e,0x0f,0x9f,0x03,0xf3,0xff,0x9f,0x80,0x1f,0x9f,0x81,0xf9,0xfc,0x3f,0x9d,0x80
,0x3f,0x1f,0xbf,0x03,0xf3,0xfc,0x1f,0x80,0x3f,0x9f,0x81,0xf9,0xfc,0x1f,0x9f,0x80
,0x3f,0x1f,0xbf,0x01,0xf3,0xf8,0x1f,0x80,0x7f,0x1f,0x00,0xfd,0xf8,0x1f,0x8f,0x80
,0x1f,0x1f,0x3f,0xff,0xf3,0xf0,0x1f,0x80,0x7e,0x1f,0x00,0xfd,0xf8,0x1f,0x8f,0x00
,0x1f,0x1f,0x3f,0xff,0xf3,0xf0,0x1f,0x80,0xfc,0x3f,0x00,0xfd,0xf8,0x1f,0x8f,0x00
,0x1f,0x9f,0x3f,0xff,0xfb,0xf0,0x1f,0x81,0xfc,0x3f,0x00,0xfd,0xf8,0x1f,0x86,0x00
,0x1f,0xbf,0x3f,0xff,0xfb,0xf0,0x1f,0x83,0xf8,0x3f,0x00,0xfd,0xf8,0x1f,0x80,0x00
,0x0f,0xbe,0x3f,0xff,0xfb,0xf0,0x1f,0x83,0xf0,0x3f,0x00,0xfd,0xf8,0x1f,0x80,0x00
,0x0f,0xfe,0x3e,0x00,0x03,0xf0,0x1f,0x87,0xe0,0x1f,0x00,0xfd,0xf8,0x1f,0x80,0x00
,0x0f,0xfe,0x3f,0x00,0x03,0xf0,0x1f,0x8f,0xe0,0x1f,0x00,0xfd,0xf8,0x1f,0x80,0x00
,0x07,0xfc,0x3f,0x01,0xf3,0xf0,0x1f,0x9f,0xc0,0x1f,0x81,0xf9,0xf8,0x1f,0x80,0x00
,0x07,0xfc,0x1f,0x83,0xf3,0xf0,0x1f,0x9f,0xc0,0x1f,0x81,0xf9,0xf8,0x1f,0x80,0x00
,0x07,0xfc,0x1f,0xc7,0xf3,0xf0,0x1f,0xbf,0xff,0xcf,0xe7,0xf9,0xf8,0x1f,0x80,0x00
,0x03,0xfc,0x0f,0xff,0xe3,0xf0,0x1f,0xbf,0xff,0xcf,0xff,0xf1,0xf8,0x1f,0x80,0x00
,0x03,0xf8,0x07,0xff,0xc3,0xf0,0x1f,0xbf,0xff,0xc7,0xff,0xe1,0xf8,0x1f,0x80,0x00
,0x03,0xf8,0x07,0xff,0xc3,0xf0,0x1f,0xbf,0xff,0xc3,0xff,0xc1,0xf8,0x1f,0x80,0x00
,0x03,0xf8,0x01,0xff,0x03,0xf0,0x1f,0xbf,0xff,0xc1,0xff,0x81,0xf8,0x1f,0x80,0x00
,0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00 };

#if (SSD1306_LCDHEIGHT != 64)
#error("Height incorrect, please fix Adafruit_SSD1306.h!");
#endif

void drawlogo(const unsigned char* bitmap, int width, int height) {
  // draw the logo centered on the screen
  int xoffset = (SSD1306_LCDWIDTH-width)/2;
  int yoffset = (SSD1306_LCDHEIGHT-height)/2;
  display.drawBitmap(xoffset, yoffset, bitmap, width, height, WHITE);
}

void checkButtons() {
  // Pull-ups have inverted logic
  // true aka HIGH is open button
  static bool button1State = true;
  static bool button1LastState = true;
  static bool button2State = true;
  static bool button2LastState = true;

  // debounce buttons
  static unsigned long lastDebounceTime1 = 0;
  static unsigned long lastDebounceTime2 = 0;
  static bool prelimButton1State = true;
  static bool prelimButton2State = true;

  bool reading1 = digitalRead(BUTTON_1_PIN);
  bool reading2 = digitalRead(BUTTON_2_PIN);

  if(reading1!=prelimButton1State) {
    lastDebounceTime1 = now;
  }
  if((now-lastDebounceTime1)>DEBOUNCE_DELAY) {
    button1State = reading1;
  }
  prelimButton1State = reading1;
 
  if(reading2!=prelimButton2State) {
    lastDebounceTime2 = now;
  }
  if((now-lastDebounceTime2)>DEBOUNCE_DELAY) {
    button2State = reading2;
  }
  prelimButton2State = reading2;

  // check whether buttons have been pressed
  // rather than released
  if(button1State==false && button1LastState==true) {
    eventFlags[BUTTON_1_PRESS] = true;
#ifndef NDEBUG
    Serial.println("Button 1 pressed");
#endif
  }
  if(button2State==false && button2LastState==true) {
    eventFlags[BUTTON_2_PRESS] = true;
 #ifndef NDEBUG
    Serial.println("Button 2 pressed");
 #endif
  }

  button1LastState = button1State;
  button2LastState = button2State;
}

void checkTimer() {
  if((now-timerStart)>SENSOR_PERIOD) {
    eventFlags[SENSOR_TIMEOUT] = true;
  }
}

void clearButton1() {
  eventFlags[BUTTON_1_PRESS] = false;
}

void clearButton2() {
  eventFlags[BUTTON_2_PRESS] = false;
}

void clearButtons() {
  clearButton1();
  clearButton2();
}

void resetTimer() {
  eventFlags[SENSOR_TIMEOUT] = false;
  timerStart = now;
}

void getSensor() {
  sensors_event_t event;
  accel.getEvent(&event);
  temperature = event.acceleration.x;
  humidity = event.acceleration.y;
  pressure = event.acceleration.z;
}

void printSensor() {
  display.clearDisplay();
  display.setCursor(0, 0);
  if(metric) {
    display.print(temperature);
  }
  else {
    display.print(1.8F*temperature+32.0f);
  }
  // F7 is the degree symbol character code
  display.print(" \xF7"); 
  if(metric) {
    display.println('C');
  }
  else {
    display.println('F');
  }
  display.print(humidity); display.println(" %");
  if(metric) {
    display.print(pressure); 
  }
  else {
    display.print(pressure*0.02953f);
  }
  if(metric) {
    display.println(" hPa");
  }
  else {
    display.println(" inHg");
  }
  display.display();
}

void printUnit() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.println("Units:");
  if(metric) {
    display.println("Metric");
  }
  else {
    display.println("Imperial");
  }
  display.display();
}

void processEvents() {
  // process events dependent on state
  switch(state) {
    case IDLE_STATE:
      if(eventFlags[SENSOR_TIMEOUT]){
        state = DISPLAY_LAST;
      }
      if(eventFlags[BUTTON_1_PRESS]){
        state = DISPLAY_UNIT;
      }
      clearButtons();
      break;
    case DISPLAY_UNIT:
      printUnit();
      if(eventFlags[BUTTON_1_PRESS]){
        state = DISPLAY_LAST;
      }
      if(eventFlags[BUTTON_2_PRESS]){
        metric = !metric;
      }
      clearButtons();
      resetTimer();
      break;
    case DISPLAY_LAST:
      getSensor();
      printSensor();
      state = IDLE_STATE;
      resetTimer();
      break;
    default:
#ifndef NDEBUG
      Serial.println(F("Unknown state in processEvents()"));
#endif
    while (1) delay(1000);
  }
}

void setup() {
#ifndef NDEBUG
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
  Serial.println("Initializing...");
#endif
  // display splash screen
  display.begin(SSD1306_SWITCHCAPVCC, 0x3D);  // initialize with the I2C addr 0x3D (for the 128x64)
  display.clearDisplay();
  drawlogo(ksu_logo_bits, ksu_logo_width, ksu_logo_height);
  display.display();
  delay(2000);
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.setCursor(0,10);
  display.println(F(" Kentucky\n   State\nUniversity"));
  display.display();
  delay(2000);
  display.clearDisplay();
  drawlogo(verizon_logo_bits, verizon_logo_width, verizon_logo_height);
  display.display();
  delay(2000);
  // Initialize the sensor
  if(!accel.begin()) {
    display.clearDisplay();
    display.setCursor(0,10);
    display.println(F("No sensor\ndetected."));
    display.display();
    while(1);
  }
  state = DISPLAY_LAST;
  pinMode(BUTTON_1_PIN, INPUT_PULLUP);
  pinMode(BUTTON_2_PIN, INPUT_PULLUP);
  now = millis();
  timerStart = now;
}

void loop() {
  now = millis();
  checkButtons();
  checkTimer();
  processEvents();
}
